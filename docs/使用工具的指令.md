# 使用 Graphiti MCP 工具的指令

## 開始任何任務之前

**始終先搜索：** 在開始工作之前，使用 `search_memory_nodes` 工具查詢相關的偏好設定和程式。

**同時搜索事實：** 使用 `search_memory_facts` 工具發現可能與您的任務相關的關係和事實資訊。

**按實體型別過濾：** 在節點搜索中指定"Preference"（偏好）或"Procedure"（程式）以獲得針對性結果。

**審查所有匹配項：** 仔細檢查與目前任務匹配的任何偏好、程式或事實。

## 始終儲存新的或更新的資訊

**立即捕獲需求和偏好：** 當用戶表達需求或偏好時，立即使用 `add_memory_simple` 儲存它。最佳實踐是將很長的需求拆分為較短的邏輯塊。

**明確標識更新：** 如果某些內容是對現有知識的更新，請明確說明。

**清晰記錄程式：** 當您發現使用者希望如何完成某些操作時，將其記錄為程式。

**記錄事實關係：** 當您瞭解到實體之間的連線時，將這些資訊儲存為事實。

**明確分類：** 為偏好和程式標註清晰的類別，以便日後更好地檢索。

## 工作過程中

**遵循發現的偏好：** 使您的工作與找到的任何偏好保持一致。

**嚴格按照程式執行：** 如果找到適用於目前任務的程式，請嚴格按步驟執行。

**應用相關事實：** 使用事實資訊來指導您的決策和建議。

**保持一致性：** 與先前識別的偏好、程式和事實保持一致。

## 最佳實踐

**建議前先搜索：** 在提出建議之前，始終檢查是否存在既定知識。

**結合節點和事實搜索：** 對於複雜任務，同時搜索節點和事實以構建完整圖景。

**使用 center_node_uuid：** 在探索相關資訊時，圍繞特定節點進行搜索。

**優先考慮具體匹配：** 更具體的資訊優先於一般資訊。

**主動識別模式：** 如果您注意到使用者行為中的模式，考慮將其儲存為偏好或程式。

**重要提醒：** 知識圖譜是您的記憶。持續使用它來提供個性化協助，尊重使用者既定的程式和事實背景。

## 可用的 MCP 工具

### 記憶管理工具

- **`add_memory_simple`** - 添加記憶片段到知識圖譜
  - `name`: 記憶片段的名稱
  - `episode_body`: 記憶片段的內容
  - `group_id`: 記憶分組 ID（可選，預設為 "default"）

- **`search_memory_nodes`** - 搜尋記憶節點
  - `query`: 搜尋關鍵字
  - `max_nodes`: 返回節點的最大數量（預設 10）
  - `group_ids`: 用於篩選的分組 ID（可選）

- **`search_memory_facts`** - 搜尋記憶事實
  - `query`: 搜尋關鍵字
  - `max_facts`: 返回事實的最大數量（預設 10）
  - `group_ids`: 用於篩選的分組 ID（可選）

- **`get_episodes`** - 獲取最近的記憶
  - `last_n`: 獲取最近記憶片段的數量（預設 10）
  - `group_id`: 用於篩選的分組 ID（可選）

### 系統工具

- **`test_connection`** - 測試連接狀態
  - 檢查 Neo4j、Ollama LLM 和嵌入器的連接狀態

## 工作流程範例

### 1. 開始新任務
```
1. search_memory_nodes(query="任務相關關鍵字")
2. search_memory_facts(query="相關事實")
3. 分析搜索結果
4. 執行任務
5. add_memory_simple(name="任務結果", episode_body="詳細描述")
```

### 2. 儲存用戶偏好
```
用戶：「我喜歡用簡潔的代碼風格」
動作：add_memory_simple(
  name="代碼風格偏好",
  episode_body="用戶偏好使用簡潔的代碼風格，避免冗長的實現"
)
```

### 3. 記錄操作程序
```
用戶：「部署時先運行測試，然後構建，最後發佈」
動作：add_memory_simple(
  name="部署程序",
  episode_body="部署流程：1. 運行測試 2. 構建應用 3. 發佈到生產環境"
)
```

## 注意事項

- 記憶內容應該清晰、具體且有意義
- 使用適當的分組 ID 來組織不同類型的記憶
- 定期檢查和更新過時的資訊
- 保持記憶片段的邏輯大小，避免過長或過短
- 使用描述性的名稱來便於後續檢索